"""
ML-based Vulnerability Analyzer

This module provides ML-based vulnerability detection using BERT embeddings.
"""

import logging
from typing import Dict, Optional, Tuple, Any

import torch
import numpy as np
from transformers import AutoTokenizer, AutoModel

logger = logging.getLogger(__name__)

class MLVulnerabilityWeightCalculator:
    """Analyzes contract code for ML-based vulnerability patterns using BERT embeddings."""

    def __init__(self, model_path: str = 'microsoft/codebert-base') -> None:
        """Initialize the MLVulnerabilityWeightCalculator.
        
        Args:
            model_path: Path to the pre-trained model or model identifier from huggingface.co/models
            
        Raises:
            ImportError: If required ML dependencies are not available
        """
        try:
            self.tokenizer = AutoTokenizer.from_pretrained(model_path)
            self.model = AutoModel.from_pretrained(model_path)
            
            # Initialize vulnerability type embeddings
            self.vulnerability_embeddings = {
                'reentrancy': self._embed_vulnerability_type('reentrancy attack external call state change'),
                'access_control': self._embed_vulnerability_type('unauthorized access control ownership'),
                'selfdestruct': self._embed_vulnerability_type('contract self destruction owner control'),
                'external_call': self._embed_vulnerability_type('unguarded external call low-level call'),
                'economic_manipulation': self._embed_vulnerability_type('price oracle liquidity manipulation')
            }
            logger.info("ML model and tokenizer initialized successfully")
        except ImportError as e:
            error_msg = 'Machine learning dependencies not available. Install with: pip install torch transformers'
            logger.error(error_msg)
            raise ImportError(error_msg) from e
        except Exception as e:
            logger.error("Failed to initialize ML model: %s", str(e))
            raise

    def _embed_vulnerability_type(self, description: str) -> torch.Tensor:
        """Generate embedding for a vulnerability type description.
        
        Args:
            description: Text description of the vulnerability type
            
        Returns:
            torch.Tensor: Embedding vector
        """
        try:
            inputs = self.tokenizer(description, return_tensors='pt', truncation=True, max_length=512)
            with torch.no_grad():
                outputs = self.model(**inputs)
            return outputs.last_hidden_state.mean(dim=1).flatten()
        except Exception as e:
            logger.error("Error generating embedding: %s", str(e))
            raise

    def calculate_code_vulnerability_similarity(self, contract_code: str) -> Dict[str, float]:
        """Calculate similarity scores between contract code and known vulnerability types.
        
        Args:
            contract_code: Source code of the contract to analyze
            
        Returns:
            Dict[str, float]: Dictionary mapping vulnerability types to similarity scores
        """
        try:
            contract_embedding = self._embed_vulnerability_type(contract_code)
            similarities = {}
            
            for vuln_type, vuln_embedding in self.vulnerability_embeddings.items():
                similarity = torch.nn.functional.cosine_similarity(
                    contract_embedding.unsqueeze(0), 
                    vuln_embedding.unsqueeze(0)
                ).item()
                similarities[vuln_type] = similarity
                
            return similarities
        except Exception as e:
            logger.error("Error calculating code vulnerability similarity: %s", str(e))
            return {}

    def assess_economic_risk(self, contract_code: str) -> str:
        """Assess the economic risk level of a contract.
        
        Args:
            contract_code: Source code of the contract to analyze
            
        Returns:
            str: Risk level ('economic_risk_low', 'economic_risk_medium', 'economic_risk_high')
        """
        try:
            similarities = self.calculate_code_vulnerability_similarity(contract_code)
            economic_risk_score = similarities.get('economic_manipulation', 0)
            
            if economic_risk_score < 0.2:
                return 'economic_risk_low'
            elif economic_risk_score < 0.5:
                return 'economic_risk_medium'
            return 'economic_risk_high'
        except Exception as e:
            logger.error("Error assessing economic risk: %s", str(e))
            return 'economic_risk_medium'  # Default to medium on error
