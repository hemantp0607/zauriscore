{
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\\n    struct OwnableStorage {\\n        address _owner;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Ownable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\\n\\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\\n        assembly {\\n            $.slot := OwnableStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\\n        __Ownable_init_unchained(initialOwner);\\n    }\\n\\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        return $._owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        address oldOwner = $._owner;\\n        $._owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC3156FlashBorrower.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\\n */\\ninterface IERC3156FlashBorrower {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/1inch/AddressLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype UAddress is uint256;\\n\\n/**\\n * @dev Library for working with addresses encoded as uint256 values, which can include flags in the highest bits.\\n */\\nlibrary AddressLib {\\n    uint256 private constant _LOW_160_BIT_MASK = (1 << 160) - 1;\\n\\n    /**\\n     * @notice Returns the address representation of a uint256.\\n     * @param a The uint256 value to convert to an address.\\n     * @return The address representation of the provided uint256 value.\\n     */\\n    function get(UAddress a) internal pure returns (address) {\\n        return address(uint160(UAddress.unwrap(a) & _LOW_160_BIT_MASK));\\n    }\\n\\n    /**\\n     * @notice Checks if a given flag is set for the provided address.\\n     * @param a The address to check for the flag.\\n     * @param flag The flag to check for in the provided address.\\n     * @return True if the provided flag is set in the address, false otherwise.\\n     */\\n    function getFlag(UAddress a, uint256 flag) internal pure returns (bool) {\\n        return (UAddress.unwrap(a) & flag) != 0;\\n    }\\n\\n    /**\\n     * @notice Returns a uint32 value stored at a specific bit offset in the provided address.\\n     * @param a The address containing the uint32 value.\\n     * @param offset The bit offset at which the uint32 value is stored.\\n     * @return The uint32 value stored in the address at the specified bit offset.\\n     */\\n    function getUint32(UAddress a, uint256 offset) internal pure returns (uint32) {\\n        return uint32(UAddress.unwrap(a) >> offset);\\n    }\\n\\n    /**\\n     * @notice Returns a uint64 value stored at a specific bit offset in the provided address.\\n     * @param a The address containing the uint64 value.\\n     * @param offset The bit offset at which the uint64 value is stored.\\n     * @return The uint64 value stored in the address at the specified bit offset.\\n     */\\n    function getUint64(UAddress a, uint256 offset) internal pure returns (uint64) {\\n        return uint64(UAddress.unwrap(a) >> offset);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/1inch/IAggregationRouterV6.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Interface for making arbitrary calls during swap\\ninterface IAggregationExecutor {\\n    /// @notice propagates information about original msg.sender and executes arbitrary data\\n    function execute(address msgSender) external payable returns (uint256); // 0x4b64e492\\n}\\n\\ninterface IAggregationRouterV6 {\\n    type Address is uint256;\\n\\n    struct SwapDescription {\\n        IERC20 srcToken;\\n        IERC20 dstToken;\\n        address payable srcReceiver;\\n        address payable dstReceiver;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        uint256 flags;\\n    }\\n\\n    function swap(IAggregationExecutor executor, SwapDescription calldata desc, bytes calldata data)\\n        external\\n        returns (uint256 returnAmount, uint256 spentAmount);\\n\\n    // uno\\n\\n    /**\\n     * @notice Swaps `amount` of the specified `token` for another token using an Unoswap-compatible exchange's pool,\\n     *         with a minimum return specified by `minReturn`.\\n     * @param token The address of the token to be swapped.\\n     * @param amount The amount of tokens to be swapped.\\n     * @param minReturn The minimum amount of tokens to be received after the swap.\\n     * @param dex The address of the Unoswap-compatible exchange's pool.\\n     * @return returnAmount The actual amount of tokens received after the swap.\\n     */\\n    function unoswap(Address token, uint256 amount, uint256 minReturn, Address dex)\\n        external\\n        returns (uint256 returnAmount);\\n\\n    /**\\n     * @notice Swaps ETH for another token using an Unoswap-compatible exchange's pool, with a minimum return specified by `minReturn`.\\n     *         The function is payable and requires the sender to attach ETH.\\n     *         It is necessary to check if it's cheaper to use _WETH_NOT_WRAP_FLAG in `dex` Address (for example: for Curve pools).\\n     * @param minReturn The minimum amount of tokens to be received after the swap.\\n     * @param dex The address of the Unoswap-compatible exchange's pool.\\n     * @return returnAmount The actual amount of tokens received after the swap.\\n     */\\n    function ethUnoswap(uint256 minReturn, Address dex) external payable returns (uint256 returnAmount);\\n\\n    /**\\n     * @notice Swaps `amount` of the specified `token` for another token using two Unoswap-compatible exchange pools (`dex` and `dex2`) sequentially,\\n     *         with a minimum return specified by `minReturn`.\\n     * @param token The address of the token to be swapped.\\n     * @param amount The amount of tokens to be swapped.\\n     * @param minReturn The minimum amount of tokens to be received after the swap.\\n     * @param dex The address of the first Unoswap-compatible exchange's pool.\\n     * @param dex2 The address of the second Unoswap-compatible exchange's pool.\\n     * @return returnAmount The actual amount of tokens received after the swap through both pools.\\n     */\\n    function unoswap2(Address token, uint256 amount, uint256 minReturn, Address dex, Address dex2)\\n        external\\n        returns (uint256 returnAmount);\\n\\n    /**\\n     * @notice Swaps ETH for another token using two Unoswap-compatible exchange pools (`dex` and `dex2`) sequentially,\\n     *         with a minimum return specified by `minReturn`. The function is payable and requires the sender to attach ETH.\\n     *         It is necessary to check if it's cheaper to use _WETH_NOT_WRAP_FLAG in `dex` Address (for example: for Curve pools).\\n     * @param minReturn The minimum amount of tokens to be received after the swap.\\n     * @param dex The address of the first Unoswap-compatible exchange's pool.\\n     * @param dex2 The address of the second Unoswap-compatible exchange's pool.\\n     * @return returnAmount The actual amount of tokens received after the swap through both pools.\\n     */\\n    function ethUnoswap2(uint256 minReturn, Address dex, Address dex2)\\n        external\\n        payable\\n        returns (uint256 returnAmount);\\n\\n    /**\\n     * @notice Swaps `amount` of the specified `token` for another token using three Unoswap-compatible exchange pools\\n     *         (`dex`, `dex2`, and `dex3`) sequentially, with a minimum return specified by `minReturn`.\\n     * @param token The address of the token to be swapped.\\n     * @param amount The amount of tokens to be swapped.\\n     * @param minReturn The minimum amount of tokens to be received after the swap.\\n     * @param dex The address of the first Unoswap-compatible exchange's pool.\\n     * @param dex2 The address of the second Unoswap-compatible exchange's pool.\\n     * @param dex3 The address of the third Unoswap-compatible exchange's pool.\\n     * @return returnAmount The actual amount of tokens received after the swap through all three pools.\\n     */\\n    function unoswap3(Address token, uint256 amount, uint256 minReturn, Address dex, Address dex2, Address dex3)\\n        external\\n        returns (uint256 returnAmount);\\n\\n    /**\\n     * @notice Swaps ETH for another token using three Unoswap-compatible exchange pools (`dex`, `dex2`, and `dex3`) sequentially,\\n     *         with a minimum return specified by `minReturn`. The function is payable and requires the sender to attach ETH.\\n     *         It is necessary to check if it's cheaper to use _WETH_NOT_WRAP_FLAG in `dex` Address (for example: for Curve pools).\\n     * @param minReturn The minimum amount of tokens to be received after the swap.\\n     * @param dex The address of the first Unoswap-compatible exchange's pool.\\n     * @param dex2 The address of the second Unoswap-compatible exchange's pool.\\n     * @param dex3 The address of the third Unoswap-compatible exchange's pool.\\n     * @return returnAmount The actual amount of tokens received after the swap through all three pools.\\n     */\\n    function ethUnoswap3(uint256 minReturn, Address dex, Address dex2, Address dex3)\\n        external\\n        payable\\n        returns (uint256 returnAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/IAaveOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IAaveOracle {\\n    function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/v3/IPoolV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/types/DataTypes.sol\\\";\\n\\n/**\\n * @title IPool\\n * @author Aave\\n * @notice Defines the basic interface for an Aave Pool.\\n */\\ninterface IPoolV3 {\\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\\n\\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\\n\\n    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf)\\n        external;\\n\\n    function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf)\\n        external\\n        returns (uint256);\\n\\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\n\\n    function flashLoanSimple(\\n        address receiverAddress,\\n        address asset,\\n        uint256 amount,\\n        bytes calldata params,\\n        uint16 referralCode\\n    ) external;\\n\\n    function getUserAccountData(address user)\\n        external\\n        view\\n        returns (\\n            uint256 totalCollateralBase,\\n            uint256 totalDebtBase,\\n            uint256 availableBorrowsBase,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        );\\n\\n    function setUserEMode(uint8 categoryId) external;\\n\\n    function getUserEMode(address user) external view returns (uint256);\\n\\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\\n\\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/v3/libraries/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary DataTypes {\\n    struct ReserveData {\\n        //stores the reserve configuration\\n        ReserveConfigurationMap configuration;\\n        //the liquidity index. Expressed in ray\\n        uint128 liquidityIndex;\\n        //the current supply rate. Expressed in ray\\n        uint128 currentLiquidityRate;\\n        //variable borrow index. Expressed in ray\\n        uint128 variableBorrowIndex;\\n        //the current variable borrow rate. Expressed in ray\\n        uint128 currentVariableBorrowRate;\\n        //the current stable borrow rate. Expressed in ray\\n        uint128 currentStableBorrowRate;\\n        //timestamp of last update\\n        uint40 lastUpdateTimestamp;\\n        //the id of the reserve. Represents the position in the list of the active reserves\\n        uint16 id;\\n        //aToken address\\n        address aTokenAddress;\\n        //stableDebtToken address\\n        address stableDebtTokenAddress;\\n        //variableDebtToken address\\n        address variableDebtTokenAddress;\\n        //address of the interest rate strategy\\n        address interestRateStrategyAddress;\\n        //the current treasury balance, scaled\\n        uint128 accruedToTreasury;\\n        //the outstanding unbacked aTokens minted through the bridging feature\\n        uint128 unbacked;\\n        //the outstanding debt borrowed against this asset in isolation mode\\n        uint128 isolationModeTotalDebt;\\n    }\\n\\n    struct ReserveConfigurationMap {\\n        //bit 0-15: LTV\\n        //bit 16-31: Liq. threshold\\n        //bit 32-47: Liq. bonus\\n        //bit 48-55: Decimals\\n        //bit 56: reserve is active\\n        //bit 57: reserve is frozen\\n        //bit 58: borrowing is enabled\\n        //bit 59: stable rate borrowing enabled\\n        //bit 60: asset is paused\\n        //bit 61: borrowing in isolation mode is enabled\\n        //bit 62-63: reserved\\n        //bit 64-79: reserve factor\\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\\n        //bit 152-167 liquidation protocol fee\\n        //bit 168-175 eMode category\\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\\n        //bit 252-255 unused\\n        uint256 data;\\n    }\\n\\n    struct UserConfigurationMap {\\n        /**\\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\\n         * asset is borrowed by the user.\\n         */\\n        uint256 data;\\n    }\\n\\n    struct EModeCategory {\\n        // each eMode category has a custom ltv and liquidation threshold\\n        uint16 ltv;\\n        uint16 liquidationThreshold;\\n        uint16 liquidationBonus;\\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\\n        address priceSource;\\n        string label;\\n    }\\n\\n    enum InterestRateMode {\\n        NONE,\\n        STABLE,\\n        VARIABLE\\n    }\\n\\n    struct ReserveCache {\\n        uint256 currScaledVariableDebt;\\n        uint256 nextScaledVariableDebt;\\n        uint256 currPrincipalStableDebt;\\n        uint256 currAvgStableBorrowRate;\\n        uint256 currTotalStableDebt;\\n        uint256 nextAvgStableBorrowRate;\\n        uint256 nextTotalStableDebt;\\n        uint256 currLiquidityIndex;\\n        uint256 nextLiquidityIndex;\\n        uint256 currVariableBorrowIndex;\\n        uint256 nextVariableBorrowIndex;\\n        uint256 currLiquidityRate;\\n        uint256 currVariableBorrowRate;\\n        uint256 reserveFactor;\\n        ReserveConfigurationMap reserveConfiguration;\\n        address aTokenAddress;\\n        address stableDebtTokenAddress;\\n        address variableDebtTokenAddress;\\n        uint40 reserveLastUpdateTimestamp;\\n        uint40 stableDebtLastUpdateTimestamp;\\n    }\\n\\n    struct ExecuteLiquidationCallParams {\\n        uint256 reservesCount;\\n        uint256 debtToCover;\\n        address collateralAsset;\\n        address debtAsset;\\n        address user;\\n        bool receiveAToken;\\n        address priceOracle;\\n        uint8 userEModeCategory;\\n        address priceOracleSentinel;\\n    }\\n\\n    struct ExecuteSupplyParams {\\n        address asset;\\n        uint256 amount;\\n        address onBehalfOf;\\n        uint16 referralCode;\\n    }\\n\\n    struct ExecuteBorrowParams {\\n        address asset;\\n        address user;\\n        address onBehalfOf;\\n        uint256 amount;\\n        InterestRateMode interestRateMode;\\n        uint16 referralCode;\\n        bool releaseUnderlying;\\n        uint256 maxStableRateBorrowSizePercent;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 userEModeCategory;\\n        address priceOracleSentinel;\\n    }\\n\\n    struct ExecuteRepayParams {\\n        address asset;\\n        uint256 amount;\\n        InterestRateMode interestRateMode;\\n        address onBehalfOf;\\n        bool useATokens;\\n    }\\n\\n    struct ExecuteWithdrawParams {\\n        address asset;\\n        uint256 amount;\\n        address to;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 userEModeCategory;\\n    }\\n\\n    struct ExecuteSetUserEModeParams {\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 categoryId;\\n    }\\n\\n    struct FinalizeTransferParams {\\n        address asset;\\n        address from;\\n        address to;\\n        uint256 amount;\\n        uint256 balanceFromBefore;\\n        uint256 balanceToBefore;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 fromEModeCategory;\\n    }\\n\\n    struct FlashloanParams {\\n        address receiverAddress;\\n        address[] assets;\\n        uint256[] amounts;\\n        uint256[] interestRateModes;\\n        address onBehalfOf;\\n        bytes params;\\n        uint16 referralCode;\\n        uint256 flashLoanPremiumToProtocol;\\n        uint256 flashLoanPremiumTotal;\\n        uint256 maxStableRateBorrowSizePercent;\\n        uint256 reservesCount;\\n        address addressesProvider;\\n        uint8 userEModeCategory;\\n        bool isAuthorizedFlashBorrower;\\n    }\\n\\n    struct FlashloanSimpleParams {\\n        address receiverAddress;\\n        address asset;\\n        uint256 amount;\\n        bytes params;\\n        uint16 referralCode;\\n        uint256 flashLoanPremiumToProtocol;\\n        uint256 flashLoanPremiumTotal;\\n    }\\n\\n    struct FlashLoanRepaymentParams {\\n        uint256 amount;\\n        uint256 totalPremium;\\n        uint256 flashLoanPremiumToProtocol;\\n        address asset;\\n        address receiverAddress;\\n        uint16 referralCode;\\n    }\\n\\n    struct CalculateUserAccountDataParams {\\n        UserConfigurationMap userConfig;\\n        uint256 reservesCount;\\n        address user;\\n        address oracle;\\n        uint8 userEModeCategory;\\n    }\\n\\n    struct ValidateBorrowParams {\\n        ReserveCache reserveCache;\\n        UserConfigurationMap userConfig;\\n        address asset;\\n        address userAddress;\\n        uint256 amount;\\n        InterestRateMode interestRateMode;\\n        uint256 maxStableLoanPercent;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 userEModeCategory;\\n        address priceOracleSentinel;\\n        bool isolationModeActive;\\n        address isolationModeCollateralAddress;\\n        uint256 isolationModeDebtCeiling;\\n    }\\n\\n    struct ValidateLiquidationCallParams {\\n        ReserveCache debtReserveCache;\\n        uint256 totalDebt;\\n        uint256 healthFactor;\\n        address priceOracleSentinel;\\n    }\\n\\n    struct CalculateInterestRatesParams {\\n        uint256 unbacked;\\n        uint256 liquidityAdded;\\n        uint256 liquidityTaken;\\n        uint256 totalStableDebt;\\n        uint256 totalVariableDebt;\\n        uint256 averageStableBorrowRate;\\n        uint256 reserveFactor;\\n        address reserve;\\n        address aToken;\\n    }\\n\\n    struct InitReserveParams {\\n        address asset;\\n        address aTokenAddress;\\n        address stableDebtAddress;\\n        address variableDebtAddress;\\n        address interestRateStrategyAddress;\\n        uint16 reservesCount;\\n        uint16 maxNumberReserves;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/binance/IWBETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.21;\\n\\ninterface IWBETH {\\n  function CANCEL_AUTHORIZATION_TYPEHASH (  ) external view returns ( bytes32 );\\n  function DOMAIN_SEPARATOR (  ) external view returns ( bytes32 );\\n  function PERMIT_TYPEHASH (  ) external view returns ( bytes32 );\\n  function RECEIVE_WITH_AUTHORIZATION_TYPEHASH (  ) external view returns ( bytes32 );\\n  function TRANSFER_WITH_AUTHORIZATION_TYPEHASH (  ) external view returns ( bytes32 );\\n  function _EXCHANGE_RATE_UNIT (  ) external view returns ( uint256 );\\n  function _UNWRAP_ETH_ADDRESS (  ) external view returns ( address );\\n  function allowance ( address owner, address spender ) external view returns ( uint256 );\\n  function approve ( address spender, uint256 value ) external returns ( bool );\\n  function authorizationState ( address authorizer, bytes32 nonce ) external view returns ( bool );\\n  function balanceOf ( address account ) external view returns ( uint256 );\\n  function blacklist ( address _account ) external;\\n  function blacklister (  ) external view returns ( address );\\n  function burn ( uint256 _amount ) external;\\n  function cancelAuthorization ( address authorizer, bytes32 nonce, uint8 v, bytes32 r, bytes32 s ) external;\\n  function configureMinter ( address minter, uint256 minterAllowedAmount ) external returns ( bool );\\n  function decimals (  ) external view returns ( uint8 );\\n  function decreaseAllowance ( address spender, uint256 decrement ) external returns ( bool );\\n  function deposit ( address referral ) external;\\n  function ethReceiver (  ) external view returns ( address _ethReceiver );\\n  function exchangeRate (  ) external view returns ( uint256 _exchangeRate );\\n  function increaseAllowance ( address spender, uint256 increment ) external returns ( bool );\\n  function initializeV2_1 ( address lostAndFound ) external;\\n  function isBlacklisted ( address _account ) external view returns ( bool );\\n  function isMinter ( address account ) external view returns ( bool );\\n  function masterMinter (  ) external view returns ( address );\\n  function mint ( address _to, uint256 _amount ) external returns ( bool );\\n  function mint ( uint256 amount ) external returns ( bool );\\n  function minterAllowance ( address minter ) external view returns ( uint256 );\\n  function moveToStakingAddress ( uint256 amount ) external;\\n  function moveToUnwrapAddress ( uint256 amount ) external;\\n  function nonces ( address owner ) external view returns ( uint256 );\\n  function operator (  ) external view returns ( address _operator );\\n  function oracle (  ) external view returns ( address _oracle );\\n  function owner (  ) external view returns ( address );\\n  function pause (  ) external;\\n  function paused (  ) external view returns ( bool );\\n  function pauser (  ) external view returns ( address );\\n  function permit ( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external;\\n  function receiveWithAuthorization ( address from, address to, uint256 value, uint256 validAfter, uint256 validBefore, bytes32 nonce, uint8 v, bytes32 r, bytes32 s ) external;\\n  function removeMinter ( address minter ) external returns ( bool );\\n  function requestWithdrawEth ( uint256 wbethAmount ) external;\\n  function rescueERC20 ( address tokenContract, address to, uint256 amount ) external;\\n  function rescuer (  ) external view returns ( address );\\n  function supplyEth (  ) external;\\n  function symbol (  ) external view returns ( string memory );\\n  function totalSupply (  ) external view returns ( uint256 );\\n  function transfer ( address to, uint256 value ) external returns ( bool );\\n  function transferFrom ( address from, address to, uint256 value ) external returns ( bool );\\n  function transferOwnership ( address newOwner ) external;\\n  function transferWithAuthorization ( address from, address to, uint256 value, uint256 validAfter, uint256 validBefore, bytes32 nonce, uint8 v, bytes32 r, bytes32 s ) external;\\n  function unBlacklist ( address _account ) external;\\n  function unpause (  ) external;\\n  function updateBlacklister ( address _newBlacklister ) external;\\n  function updateEthReceiver ( address newEthReceiver ) external;\\n  function updateExchangeRate ( uint256 newExchangeRate ) external;\\n  function updateMasterMinter ( address _newMasterMinter ) external;\\n  function updateOperator ( address newOperator ) external;\\n  function updateOracle ( address newOracle ) external;\\n  function updatePauser ( address _newPauser ) external;\\n  function updateRescuer ( address newRescuer ) external;\\n  function version (  ) external view returns ( string memory );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/flashloanHelper/IFlashloanHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.25;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\\\";\\n\\ninterface IFlashloanHelper {\\n    function flashLoan(IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _params)\\n        external\\n        returns (bool);\\n\\n    function addToWhitelist(address _account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.25;\\n\\ninterface IStrategy {\\n    function getNetAssets() external returns (uint256);\\n\\n    function onTransferIn(address token, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.25;\\n\\ninterface IVault {\\n    event UpdateMarketCapacity(uint256 oldCapacityLimit, uint256 newCapacityLimit);\\n    event UpdateManagementFee(uint256 oldManagementFee, uint256 newManagementFee);\\n    event UpdateManagementFeeClaimPeriod(uint256 oldManagementFeeClaimPeriod, uint256 newManagementFeeClaimPeriod);\\n    event UpdateMaxPriceUpdatePeriod(uint256 oldMaxPriceUpdatePeriod, uint256 newMaxPriceUpdatePeriod);\\n    event UpdateRevenueRate(uint256 oldRevenueRate, uint256 newRevenueRate);\\n    event UpdateExitFeeRate(uint256 oldExitFeeRate, uint256 newExitFeeRate);\\n    event UpdateRebalancer(address oldRebalancer, address newRebalancer);\\n    event UpdateUnbackedMinter(address oldUnbackedMinter, address newUnbackedMinter);\\n    event UpdateFeeReceiver(address oldFeeReceiver, address newFeeReceiver);\\n    event UpdateRedeemOperator(address oldRedeemOperator, address newRedeemOperator);\\n    event UpdateExchangePrice(uint256 newExchangePrice, uint256 newRevenue);\\n    event TransferToStrategy(address token, uint256 amount, uint256 strategyIndex);\\n    event OptionalDeposit(address caller, address token, uint256 assets, address receiver, address referral);\\n    event OptionalRedeem(address token, uint256 shares, address receiver, address owner);\\n    event RequestRedeem(address user, uint256 shares, address token);\\n    event CollectManagementFee(uint256 assets);\\n    event CollectRevenue(uint256 revenue);\\n    event AddToken(address token);\\n    event RemoveToken(address token);\\n\\n    /**\\n     * @dev Parameters for initializing the vault contract.\\n     * @param underlyingToken The address of the underlying token for the vault.\\n     * @param name The name of the vault token.\\n     * @param symbol The symbol of the vault token.\\n     * @param marketCapacity The maximum market capacity of the vault.\\n     * @param managementFeeRate The rate of the management fee.\\n     * @param managementFeeClaimPeriod The period for claiming the management fee.\\n     * @param maxPriceUpdatePeriod The maximum allowed price update period.\\n     * @param revenueRate The rate of the revenue fee.\\n     * @param exitFeeRate The rate of the exit fee.\\n     * @param admin The address of the administrator.\\n     * @param rebalancer The address responsible for rebalancing the vault.\\n     * @param feeReceiver The address that will receive the fees.\\n     * @param redeemOperator The address of the operator responsible for redeeming shares\\n     */\\n    struct VaultParams {\\n        address underlyingToken;\\n        string name;\\n        string symbol;\\n        uint256 marketCapacity;\\n        uint256 managementFeeRate;\\n        uint256 managementFeeClaimPeriod;\\n        uint256 maxPriceUpdatePeriod;\\n        uint256 revenueRate;\\n        uint256 exitFeeRate;\\n        address admin;\\n        address rebalancer;\\n        address feeReceiver;\\n        address redeemOperator;\\n    }\\n\\n    /**\\n     * @dev\\n     * @param exchangePrice The exchange rate used during user deposit and withdrawal operations.\\n     * @param revenueExchangePrice The exchange rate used when calculating performance fees,Performance fees will be recorded when the real exchange rate exceeds this rate.\\n     * @param revenue Collected revenue, stored in pegged ETH.\\n     * @param lastClaimMngFeeTime The last time the management fees were charged.\\n     * @param lastUpdatePriceTime The last time the exchange price was updated.\\n     */\\n    struct VaultState {\\n        uint256 exchangePrice;\\n        uint256 revenueExchangePrice;\\n        uint256 revenue;\\n        uint256 lastClaimMngFeeTime;\\n        uint256 lastUpdatePriceTime;\\n    }\\n\\n    function optionalRedeem(address _token, uint256 _shares, uint256 _cutPercentage, address _receiver, address _owner)\\n        external\\n        returns (uint256 assetsAfterFee_);\\n\\n    function getWithdrawFee(uint256 _amount) external view returns (uint256 amount_);\\n\\n    function exchangePrice() external view returns (uint256);\\n\\n    function revenueExchangePrice() external view returns (uint256);\\n\\n    function revenue() external view returns (uint256);\\n\\n    function lastExchangePrice() external view returns (uint256);\\n\\n    function getPrecison() external view returns (uint256);\\n\\n    function burnUnbacked(uint256 _amount) external;\\n\\n    function mintUnbacked(uint256 _amount) external;\\n\\n    function optionalDeposit(address _token, uint256 _assets, address _receiver, address _referral)\\n        external\\n        payable\\n        returns (uint256 shares_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/kelp/ILRTDepositPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.21;\\n\\ninterface ILRTDepositPool {\\n    //errors\\n    error InvalidAmountToDeposit();\\n    error NotEnoughAssetToTransfer();\\n    error MaximumDepositLimitReached();\\n    error MaximumNodeDelegatorLimitReached();\\n    error InvalidMaximumNodeDelegatorLimit();\\n    error MinimumAmountToReceiveNotMet();\\n    error NodeDelegatorNotFound();\\n    error NodeDelegatorHasAssetBalance(address assetAddress, uint256 assetBalance);\\n    error NodeDelegatorHasETH();\\n    error EthTransferFailed();\\n\\n    //events\\n    event MaxNodeDelegatorLimitUpdated(uint256 maxNodeDelegatorLimit);\\n    event NodeDelegatorAddedinQueue(address[] nodeDelegatorContracts);\\n    event NodeDelegatorRemovedFromQueue(address nodeDelegatorContracts);\\n    event AssetDeposit(\\n        address indexed depositor,\\n        address indexed asset,\\n        uint256 depositAmount,\\n        uint256 rsethMintAmount,\\n        string referralId\\n    );\\n    event ETHDeposit(address indexed depositor, uint256 depositAmount, uint256 rsethMintAmount, string referralId);\\n    event MinAmountToDepositUpdated(uint256 minAmountToDeposit);\\n    event MaxNegligibleAmountUpdated(uint256 maxNegligibleAmount);\\n    event ETHSwappedForLST(uint256 ethAmount, address indexed toAsset, uint256 returnAmount);\\n    event EthTransferred(address to, uint256 amount);\\n\\n    function depositETH(\\n        uint256 minRSETHAmountExpected,\\n        string calldata referralId\\n    ) external payable;\\n\\n    // functions\\n    function depositAsset(\\n        address asset,\\n        uint256 depositAmount,\\n        uint256 minRSETHAmountExpected,\\n        string calldata referralId\\n    ) external;\\n\\n    function getSwapETHToAssetReturnAmount(address toAsset, uint256 ethAmountToSend)\\n        external\\n        view\\n        returns (uint256 returnAmount);\\n\\n    function getTotalAssetDeposits(address asset) external view returns (uint256);\\n\\n    function getAssetCurrentLimit(address asset) external view returns (uint256);\\n\\n    function getRsETHAmountToMint(address asset, uint256 depositAmount) external view returns (uint256);\\n\\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContract) external;\\n\\n    function transferAssetToNodeDelegator(uint256 ndcIndex, address asset, uint256 amount) external;\\n\\n    function updateMaxNodeDelegatorLimit(uint256 maxNodeDelegatorLimit) external;\\n\\n    function getNodeDelegatorQueue() external view returns (address[] memory);\\n\\n    function getAssetDistributionData(address asset)\\n        external\\n        view\\n        returns (\\n            uint256 assetLyingInDepositPool,\\n            uint256 assetLyingInNDCs,\\n            uint256 assetStakedInEigenLayer,\\n            uint256 assetUnstakingFromEigenLayer,\\n            uint256 assetLyingInConverter,\\n            uint256 assetLyingUnstakingVault\\n        );\\n\\n    function getETHDistributionData()\\n        external\\n        view\\n        returns (\\n            uint256 ethLyingInDepositPool,\\n            uint256 ethLyingInNDCs,\\n            uint256 ethStakedInEigenLayer,\\n            uint256 ethUnstakingFromEigenLayer,\\n            uint256 ethLyingInConverter,\\n            uint256 ethLyingInUnstakingVault\\n        );\\n\\n    function isNodeDelegator(address nodeDelegatorContract) external view returns (uint256);\\n\\n    // receivers\\n    function receiveFromRewardReceiver() external payable;\\n    function receiveFromLRTConverter() external payable;\\n    function receiveFromNodeDelegator() external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/kelp/ILRTOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.21;\\n\\ninterface ILRTOracle {\\n    // errors\\n    error AssetOracleNotSupported();\\n    error RSETHPriceExceedsLimit();\\n\\n    // events\\n    event AssetPriceOracleUpdate(address indexed asset, address indexed priceOracle);\\n    event RsETHPriceUpdate(uint256 newPrice);\\n    event PricePercentageLimitUpdate(uint256 newLimit);\\n\\n    // methods\\n    function getAssetPrice(address asset) external view returns (uint256);\\n    function assetPriceOracle(address asset) external view returns (address);\\n    function rsETHPrice() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/kelp/ILRTWithdrawalManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.21;\\n\\ninterface ILRTWithdrawalManager {\\n    //errors\\n    error TokenTransferFailed();\\n    error EthTransferFailed();\\n    error InvalidAmountToWithdraw();\\n    error ExceedAmountToWithdraw();\\n    error WithdrawalLocked();\\n    error WithdrawalDelayNotPassed();\\n    error ExceedWithdrawalDelay();\\n    error NoPendingWithdrawals();\\n    error AmountMustBeGreaterThanZero();\\n    error StrategyNotSupported();\\n\\n    error RsETHPriceMustBeGreaterMinimum(uint256 rsEthPrice);\\n    error AssetPriceMustBeGreaterMinimum(uint256 assetPrice);\\n\\n    struct WithdrawalRequest {\\n        uint256 rsETHUnstaked;\\n        uint256 expectedAssetAmount;\\n        uint256 withdrawalStartBlock;\\n    }\\n\\n    //events\\n    event AssetWithdrawalQueued(\\n        address indexed withdrawer, address indexed asset, uint256 rsETHUnstaked, uint256 indexed userNonce\\n    );\\n\\n    event AssetWithdrawalFinalized(\\n        address indexed withdrawer, address indexed asset, uint256 amountBurned, uint256 amountReceived\\n    );\\n    event EtherReceived(address indexed depositor, uint256 ethAmount, uint256 sharesAmount);\\n\\n    event AssetUnlocked(\\n        address indexed asset, uint256 rsEthAmount, uint256 assetAmount, uint256 rsEThPrice, uint256 assetPrice\\n    );\\n\\n    event MinAmountToWithdrawUpdated(address asset, uint256 minRsEthAmountToWithdraw);\\n    event WithdrawalDelayBlocksUpdated(uint256 withdrawalDelayBlocks);\\n\\n    // methods\\n\\n    function getExpectedAssetAmount(address asset, uint256 amount) external view returns (uint256);\\n\\n    function getAvailableAssetAmount(address asset) external view returns (uint256 assetAmount);\\n\\n    function getUserWithdrawalRequest(address asset, address user, uint256 index)\\n        external\\n        view\\n        returns (uint256 rsETHAmount, uint256 expectedAssetAmount, uint256 withdrawalStartBlock, uint256 userNonce);\\n\\n    function initiateWithdrawal(address asset, uint256 withdrawAmount, string memory referral) external;\\n\\n    function completeWithdrawal(address asset, string memory referral) external;\\n\\n    function unlockQueue(address asset, uint256 index, uint256 minimumAssetPrice, uint256 minimumRsEthPrice)\\n        external\\n        returns (uint256 rsETHBurned, uint256 assetAmountUnlocked);\\n\\n    // receive functions\\n    function receiveFromLRTUnstakingVault() external payable;\\n\\n    function nextUnusedNonce(address asset) external view returns (uint256);\\n\\n    function getRequestId(address asset, uint256 nonce) external view returns (bytes32);\\n\\n    function withdrawalRequests(bytes32 requestId)\\n        external\\n        view\\n        returns (uint256 rsETHUnstaked, uint256 expectedAssetAmount, uint256 withdrawalStartBlock);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lido/IstETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IstETH is IERC20 {\\n    function submit(address _referral) external payable returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lido/IWithdrawalNft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IWithdrawalNft {\\n    /// @notice output format struct for `_getWithdrawalStatus()` method\\n    struct WithdrawalRequestStatus {\\n        /// @notice stETH token amount that was locked on withdrawal queue for this request\\n        uint256 amountOfStETH;\\n        /// @notice amount of stETH shares locked on withdrawal queue for this request\\n        uint256 amountOfShares;\\n        /// @notice address that can claim or transfer this request\\n        address owner;\\n        /// @notice timestamp of when the request was created, in seconds\\n        uint256 timestamp;\\n        /// @notice true, if request is finalized\\n        bool isFinalized;\\n        /// @notice true, if request is claimed. Request is claimable if (isFinalized && !isClaimed)\\n        bool isClaimed;\\n    }\\n\\n    function requestWithdrawals(uint256[] calldata _amounts, address _owner)\\n        external\\n        returns (uint256[] memory requestIds);\\n\\n    function claimWithdrawal(uint256 _requestId) external;\\n\\n    function getWithdrawalStatus(uint256[] calldata _requestIds)\\n        external\\n        view\\n        returns (WithdrawalRequestStatus[] memory statuses);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lido/IWstETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWstETH is IERC20 {\\n    function wrap(uint256 _stETHAmount) external returns (uint256);\\n\\n    function unwrap(uint256 _stETHAmount) external returns (uint256);\\n\\n    function tokensPerStEth() external view returns (uint256);\\n\\n    function stEthPerToken() external view returns (uint256);\\n\\n    function getStETHByWstETH(uint256 _stETHAmount) external view returns (uint256);\\n\\n    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/weth/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"contracts/main/common/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.25;\\n\\nabstract contract Constants {\\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\\n    address public constant WSTETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\\n    address public constant WBETH = 0xa2E3356610840701BDf5611a53974510Ae27E2e1;\\n}\\n\"\r\n    },\r\n    \"contracts/main/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.25;\\n\\nlibrary Errors {\\n    // Revert Errors:\\n    error CallerNotOperator(); // 0xa5523ee5\\n    error CallerNotRebalancer(); // 0xbd72e291\\n    error CallerNotVault(); // 0xedd7338f\\n    error CallerNotMinter(); // 0x5eee367a\\n    error ExitFeeRateTooHigh(); // 0xf4d1caab\\n    error FlashloanInProgress(); // 0x772ac4e8\\n    error IncorrectState(); // 0x508c9390\\n    error InfoExpired(); // 0x4ddf4a65\\n    error InvalidAccount(); // 0x6d187b28\\n    error InvalidAdapter(); // 0xfbf66df1\\n    error InvalidAdmin(); // 0xb5eba9f0\\n    error InvalidAsset(); // 0xc891add2\\n    error InvalidWallet(); // 0x23455ba1\\n    error InvalidCaller(); // 0x48f5c3ed\\n    error InvalidClaimTime(); // 0x1221b97b\\n    error InvalidFeeReceiver(); // 0xd200485c\\n    error InvalidFlashloanCall(); // 0xd2208d52\\n    error InvalidFlashloanHelper(); // 0x8690f016\\n    error InvalidFlashloanProvider(); // 0xb6b48551\\n    error InvalidGasLimit(); // 0x98bdb2e0\\n    error InvalidInitiator(); // 0xbfda1f28\\n    error InvalidLength(); // 0x947d5a84\\n    error InvalidLimit(); // 0xe55fb509\\n    error InvalidManagementFeeClaimPeriod(); // 0x4022e4f6\\n    error InvalidManagementFeeRate(); // 0x09aa66eb\\n    error InvalidMarketCapacity(); // 0xc9034604\\n    error InvalidNetAssets(); // 0x6da79d69\\n    error InvalidNewOperator(); // 0xba0cdec5\\n    error InvalidOperator(); // 0xccea9e6f\\n    error InvalidRebalancer(); // 0xff288a8e\\n    error InvalidRedeemOperator(); // 0xd214a597\\n    error InvalidSafeProtocolRatio(); // 0x7c6b23d6\\n    error InvalidShares(); // 0x6edcc523\\n    error InvalidTarget(); // 0x82d5d76a\\n    error InvalidToken(); // 0xc1ab6dc1\\n    error InvalidTokenId(); // 0x3f6cc768\\n    error InvalidUnderlyingToken(); // 0x2fb86f96\\n    error InvalidVault(); // 0xd03a6320\\n    error InvalidWithdrawalUser(); // 0x36c17319\\n    error ManagementFeeRateTooHigh(); // 0x09aa66eb\\n    error ManagementFeeClaimPeriodTooShort(); // 0x4022e4f6\\n    error MarketCapacityTooLow(); // 0xc9034604\\n    error NotSupportedYet(); // 0xfb89ba2a\\n    error PriceNotUpdated(); // 0x1f4bcb2b\\n    error PriceUpdatePeriodTooLong(); // 0xe88d3ecb\\n    error RatioOutOfRange(); // 0x9179cbfa\\n    error RevenueFeeRateTooHigh(); // 0x0674143f\\n    error UnSupportedOperation(); // 0xe9ec8129\\n    error UnsupportedToken(); // 0x6a172882\\n    error WithdrawZero(); // 0x7ea773a9\\n\\n    // for 1inch swap\\n    error OneInchInvalidReceiver(); // 0xd540519e\\n    error OneInchInvalidToken(); // 0x8e7ad912\\n    error OneInchInvalidInputAmount(); // 0x672b500f\\n    error OneInchInvalidFunctionSignature(); // 0x247f51aa\\n    error OneInchUnexpectedSpentAmount(); // 0x295ada05\\n    error OneInchUnexpectedReturnAmount(); // 0x05e64ca8\\n    error OneInchNotSupported(); // 0x04b2de78\\n}\\n\"\r\n    },\r\n    \"contracts/main/strategies/aavev3/StrategyAAVEV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.25;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../../../interfaces/flashloanHelper/IFlashloanHelper.sol\\\";\\nimport \\\"../../../interfaces/binance/IWBETH.sol\\\";\\nimport \\\"../../../interfaces/lido/IWstETH.sol\\\";\\nimport \\\"../../../interfaces/IVault.sol\\\";\\nimport \\\"../../../interfaces/aave/v3/IPoolV3.sol\\\";\\nimport \\\"../../../interfaces/aave/IAaveOracle.sol\\\";\\nimport \\\"../../../interfaces/weth/IWETH.sol\\\";\\nimport \\\"../../../interfaces/lido/IstETH.sol\\\";\\nimport \\\"../../../interfaces/lido/IWithdrawalNft.sol\\\";\\nimport \\\"../../../interfaces/kelp/ILRTDepositPool.sol\\\";\\nimport \\\"../../../interfaces/kelp/ILRTOracle.sol\\\";\\nimport \\\"../../../interfaces/kelp/ILRTWithdrawalManager.sol\\\";\\nimport \\\"../../../interfaces/IStrategy.sol\\\";\\nimport \\\"../../libraries/Errors.sol\\\";\\nimport \\\"../../swap/OneInchCallerV6.sol\\\";\\n\\n/**\\n * @title StrategyAAVEV3RSETH contract\\n * @author Naturelab\\n * @dev This contract is the actual address of the strategy pool, which\\n * manages some assets in aaveV3.\\n */\\ncontract StrategyAAVEV3 is IStrategy, OneInchCallerV6, OwnableUpgradeable {\\n    using SafeERC20 for IERC20;\\n    using Math for uint256;\\n\\n    // The version of the contract\\n    string public constant VERSION = \\\"1.0\\\";\\n\\n    uint256 internal constant PRECISION = 1e18;\\n\\n    // The time limit of max days between two exchange price update\\n    uint256 public constant MAX_PRICE_UPDATED_PERIOD = 14 days;\\n\\n    // The maximum allowable ratio for the protocol, set to 91%\\n    uint256 public constant MAX_PROTOCOL_RATIO = 0.91e18;\\n\\n    address public constant RSETH = 0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7;\\n\\n    // The address of the AAVE v3 aToken for rsETH\\n    address internal constant A_RSETH_AAVEV3 = 0x2D62109243b87C4bA3EE7bA1D91B0dD0A074d7b1;\\n\\n    // The address of the AAVE v3 variable debt token for WSTETH\\n    address internal constant D_WSTETH_AAVEV3 = 0xC96113eED8cAB59cD8A66813bCB0cEb29F06D2e4;\\n\\n    // The address of the AAVE v3 variable debt token for WETH\\n    address internal constant D_WETH_AAVEV3 = 0xeA51d7853EEFb32b6ee06b1C12E6dcCA88Be0fFE;\\n\\n    // The address of the Lido withdrawal queue contract\\n    IWithdrawalNft internal constant lidoQueue = IWithdrawalNft(0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1);\\n\\n    // The address of the AAVE v3 supply token for this strategy. Now is rsETH.\\n    address internal constant SUPPLY_TOKEN = RSETH;\\n\\n    // The address of the AAVE v3 Oracle contract\\n    IAaveOracle internal constant ORACLE_AAVEV3 = IAaveOracle(0x54586bE62E3c3580375aE3723C145253060Ca0C2);\\n\\n    // The address of the AAVE v3 Pool contract\\n    IPoolV3 internal constant POOL_AAVEV3 = IPoolV3(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2);\\n\\n    ILRTWithdrawalManager internal constant kelpWithdrawal =\\n        ILRTWithdrawalManager(0x62De59c08eB5dAE4b7E6F7a8cAd3006d6965ec16);\\n\\n    ILRTOracle internal constant kelpOracle = ILRTOracle(0x349A73444b1a310BAe67ef67973022020d70020d);\\n\\n    ILRTDepositPool internal constant kelpPool = ILRTDepositPool(0x036676389e48133B63a802f8635AD39E752D375D);\\n\\n    // The address of the Vault contract that manages user shares\\n    address public vault;\\n\\n    // The intermediary contract for executing flashloan operations\\n    address public flashloanHelper;\\n\\n    // The address used to prevent flashloan re-entry attacks\\n    address public executor;\\n\\n    // The address of the position adjustment manager\\n    address public rebalancer;\\n\\n    // The safe collateral rate for the protocol\\n    uint256 public safeProtocolRatio;\\n\\n    // The net value\\n    uint256 public netAssets;\\n\\n    // The ceffu address to receive the wbeth and borrow eth\\n    address public ceffu;\\n\\n    // Setting of max update interval\\n    uint256 public maxPriceUpdatePeriod;\\n\\n    // The last time the price was updated\\n    uint256 public lastUpdateTime;\\n\\n    bytes32 public requestId;\\n\\n    uint256 public lidoUnstakeId;\\n\\n    event UpdateFlashloanHelper(address oldFlashloanHelper, address newFlashloanHelper);\\n    event UpdateRebalancer(address oldRebalancer, address newRebalancer);\\n    event UpdateSafeProtocolRatio(uint256 oldSafeProtocolRatio, uint256 newSafeProtocolRatio);\\n    event UpdateCeffu(address oldCeffu, address newCeffu);\\n    event OnTransferIn(address token, uint256 amount);\\n    event TransferToVault(address token, uint256 amount);\\n    event UpdateNetAsset(uint256 netAssets);\\n    event SwapToken(uint256 amount, address srcToken, address dstToken, uint256 swapGet);\\n    event StakeRsETH(uint256 amount);\\n    event StakeETH(uint256 amount);\\n    event UnstakeRsETH(uint256 amount);\\n    event UnstakeETH(uint256 amount);\\n    event Leverage(uint256 deposit, uint256 debtAmount, bytes swapData, uint256 flashloanSelector);\\n    event Deleverage(uint256 deleverageAmount, uint256 withdrawAmount, bytes swapData, uint256 flashloanSelector);\\n    event Repay(uint256 amount);\\n\\n    /**\\n     * @dev Ensure that this method is only called by the Vault contract.\\n     */\\n    modifier onlyVault() {\\n        if (msg.sender != vault) revert Errors.CallerNotVault();\\n        _;\\n    }\\n\\n    /**\\n     * @dev  Ensure that this method is only called by authorized portfolio managers.\\n     */\\n    modifier onlyRebalancer() {\\n        if (msg.sender != rebalancer) revert Errors.CallerNotRebalancer();\\n        _;\\n    }\\n\\n    modifier rebalancerOrOwner() {\\n        if (msg.sender != rebalancer && msg.sender != owner()) revert Errors.CallerNotRebalancer();\\n        _;\\n    }\\n\\n    modifier tokenCheck(address _token) {\\n        if (_token != WETH && _token != WSTETH) revert Errors.UnsupportedToken();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize the strategy with given parameters.\\n     * @param _initBytes Initialization data\\n     */\\n    function initialize(bytes calldata _initBytes) external initializer {\\n        (\\n            uint256 safeProtocolRatio_,\\n            address admin_,\\n            address flashloanHelper_,\\n            address rebalancer_,\\n            address ceffu_,\\n            uint256 maxPriceUpdatePeriod_\\n        ) = abi.decode(_initBytes, (uint256, address, address, address, address, uint256));\\n        if (admin_ == address(0)) revert Errors.InvalidAdmin();\\n        if (flashloanHelper_ == address(0)) revert Errors.InvalidFlashloanHelper();\\n        if (safeProtocolRatio_ > MAX_PROTOCOL_RATIO) revert Errors.InvalidSafeProtocolRatio();\\n        if (rebalancer_ == address(0)) revert Errors.InvalidRebalancer();\\n        if (maxPriceUpdatePeriod > MAX_PRICE_UPDATED_PERIOD) revert Errors.PriceUpdatePeriodTooLong();\\n        __Ownable_init(admin_);\\n        flashloanHelper = flashloanHelper_;\\n        safeProtocolRatio = safeProtocolRatio_;\\n        rebalancer = rebalancer_;\\n        vault = msg.sender;\\n        ceffu = ceffu_;\\n        maxPriceUpdatePeriod = maxPriceUpdatePeriod_;\\n        lastUpdateTime = block.timestamp;\\n        enterProtocol();\\n    }\\n\\n    /**\\n     * @dev Update the address of the intermediary contract used for flashloan operations.\\n     * @param _newFlashloanHelper The new contract address.\\n     */\\n    function updateFlashloanHelper(address _newFlashloanHelper) external onlyOwner {\\n        if (_newFlashloanHelper == address(0)) revert Errors.InvalidFlashloanHelper();\\n        emit UpdateFlashloanHelper(flashloanHelper, _newFlashloanHelper);\\n        flashloanHelper = _newFlashloanHelper;\\n    }\\n\\n    /**\\n     * @dev Add a new address to the position adjustment whitelist.\\n     * @param _newRebalancer The new address to be added.\\n     */\\n    function updateRebalancer(address _newRebalancer) external onlyOwner {\\n        if (_newRebalancer == address(0)) revert Errors.InvalidRebalancer();\\n        emit UpdateRebalancer(rebalancer, _newRebalancer);\\n        rebalancer = _newRebalancer;\\n    }\\n\\n    /**\\n     * @dev Update the address of the ceffu.\\n     * @param _newCeffu The new address to be added.\\n     */\\n    function updateCeffu(address _newCeffu) external onlyOwner {\\n        if (_newCeffu == address(0)) revert Errors.InvalidAdmin();\\n        emit UpdateCeffu(ceffu, _newCeffu);\\n        ceffu = _newCeffu;\\n    }\\n\\n    function updateSafeProtocolRatio(uint256 _newRatio) external onlyOwner {\\n        if (_newRatio > MAX_PROTOCOL_RATIO) revert Errors.InvalidSafeProtocolRatio();\\n        emit UpdateSafeProtocolRatio(safeProtocolRatio, _newRatio);\\n        safeProtocolRatio = _newRatio;\\n    }\\n\\n    function updateNetAsset(uint256 _netAssets) external rebalancerOrOwner {\\n        lastUpdateTime = block.timestamp;\\n        netAssets = _netAssets;\\n        emit UpdateNetAsset(_netAssets);\\n    }\\n\\n    /**\\n     * @dev Transfers funds from the vault contract to this contract.\\n     * This function is called by the vault to move tokens into this contract.\\n     * It uses the `safeTransferFrom` function from the SafeERC20 library to ensure the transfer is successful.\\n     * @param _token The address of the token to be transferred.\\n     * @param _amount The amount of tokens to be transferred.\\n     * @return A boolean indicating whether the transfer was successful.\\n     */\\n    function onTransferIn(address _token, uint256 _amount) external override onlyVault returns (bool) {\\n        if (_token == WETH) {\\n            IERC20(WETH).safeTransferFrom(msg.sender, address(this), _amount);\\n            netAssets += _amount.mulDiv(1e18, IWBETH(WBETH).exchangeRate(), Math.Rounding.Ceil);\\n        } else if (_token == WBETH) {\\n            IERC20(WBETH).safeTransferFrom(msg.sender, address(this), _amount);\\n            netAssets += _amount;\\n        } else {\\n            revert Errors.InvalidUnderlyingToken();\\n        }\\n        emit OnTransferIn(_token, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens to the Vault.\\n     * @param _token The address of the token to transfer.\\n     * @param _amount The amount of tokens to transfer.\\n     */\\n    function transferToVault(address _token, uint256 _amount) external onlyRebalancer {\\n        if (_token != WBETH) revert Errors.InvalidUnderlyingToken();\\n        if (netAssets > _amount) {\\n            netAssets -= _amount;\\n        } else {\\n            netAssets = 0;\\n        }\\n        IERC20(_token).safeTransfer(vault, _amount);\\n        emit TransferToVault(_token, _amount);\\n    }\\n\\n    function transferToCeffu(address _asset, uint256 _amount) external onlyRebalancer {\\n        if (_asset == WBETH) {\\n            IERC20(_asset).safeTransfer(ceffu, _amount);\\n        } else if (_asset == ETH) {\\n            (bool success,) = ceffu.call{value: _amount}(\\\"\\\");\\n            if (!success) {\\n                revert Errors.InvalidWithdrawalUser();\\n            }\\n        } else {\\n            revert Errors.InvalidAsset();\\n        }\\n    }\\n\\n    function swapToken(\\n        uint256 _amount,\\n        address _srcToken,\\n        address _dstToken,\\n        bytes memory _swapData,\\n        uint256 _swapGetMin\\n    ) external onlyRebalancer {\\n        // Allow: rsETH -> stETH, rsETH -> ETH\\n        if (_srcToken != RSETH && (_dstToken != STETH && _dstToken != ETH)) revert Errors.UnSupportedOperation();\\n        IERC20(_srcToken).safeIncreaseAllowance(ONEINCH_ROUTER, _amount);\\n        (uint256 return_,) = executeSwap(_amount, _srcToken, _dstToken, _swapData, _swapGetMin);\\n\\n        emit SwapToken(_amount, _srcToken, _dstToken, return_);\\n    }\\n\\n    /**\\n     * @dev stake STETH to RSETH.\\n     */\\n    function _stakeRsETH(address _token, uint256 _amount) internal {\\n        if (_token == STETH) {\\n            IERC20(_token).safeIncreaseAllowance(address(kelpPool), _amount);\\n            kelpPool.depositAsset(_token, _amount, 0, \\\"\\\");\\n        } else if (_token == WETH || _token == ETH) {\\n            if (_token == WETH) {\\n                _unwrap(_amount);\\n            }\\n            kelpPool.depositETH(0, \\\"\\\");\\n        }\\n\\n        emit StakeRsETH(_amount);\\n    }\\n\\n    /**\\n     * @dev unstake RSETH to STETH/ETH.\\n     */\\n    function _unstakeRsETH(uint256 _rsAmount, address _toToken) internal {\\n        if (requestId != bytes32(0)) revert Errors.UnSupportedOperation();\\n        if (_toToken != STETH && _toToken != ETH) revert Errors.UnsupportedToken();\\n        uint256 nextUnusedNonce_ = kelpWithdrawal.nextUnusedNonce(_toToken);\\n        bytes32 newRequestId_ = kelpWithdrawal.getRequestId(_toToken, nextUnusedNonce_);\\n        IERC20(RSETH).safeIncreaseAllowance(address(kelpWithdrawal), _rsAmount);\\n\\n        kelpWithdrawal.initiateWithdrawal(_toToken, _rsAmount, \\\"\\\");\\n        (uint256 rsETHUnstaked_,, uint256 withdrawalStartBlock_, uint256 userNonce_) =\\n            kelpWithdrawal.getUserWithdrawalRequest(_toToken, address(this), 0);\\n        if (rsETHUnstaked_ != _rsAmount || withdrawalStartBlock_ != block.number || nextUnusedNonce_ != userNonce_) {\\n            revert Errors.IncorrectState();\\n        }\\n        requestId = newRequestId_;\\n\\n        emit UnstakeRsETH(_rsAmount);\\n    }\\n\\n    function _stakeETH(uint256 _amount) internal {\\n        // Stake ETH to stETH\\n        IstETH(STETH).submit{value: _amount}(address(0));\\n        emit StakeETH(_amount);\\n    }\\n\\n    function _unstakeETH(uint256 _amount) internal {\\n        if (lidoUnstakeId != 0) revert Errors.IncorrectState();\\n        uint256[] memory amounts_ = new uint256[](1);\\n        amounts_[0] = _amount;\\n        IERC20(STETH).safeIncreaseAllowance(address(lidoQueue), _amount);\\n        uint256[] memory newLidoUnstakeIds_ = lidoQueue.requestWithdrawals(amounts_, address(this));\\n        lidoUnstakeId = newLidoUnstakeIds_[0];\\n        emit UnstakeETH(_amount);\\n    }\\n\\n    function _wrap(uint256 _amount) internal {\\n        // Wrap to WETH\\n        IWETH(WETH).deposit{value: _amount}();\\n    }\\n\\n    function _unwrap(uint256 _amount) internal {\\n        // Unwrap to ETH\\n        IWETH(WETH).withdraw(_amount);\\n    }\\n\\n    function _wrapStETH(uint256 _amount) internal {\\n        IERC20(STETH).safeIncreaseAllowance(WSTETH, _amount);\\n        IWstETH(WSTETH).wrap(_amount);\\n    }\\n\\n    function _unwrapStETH(uint256 _amount) internal {\\n        IWstETH(WSTETH).unwrap(_amount);\\n    }\\n\\n    function convertToken(address _fromToken, address _toToken, uint256 _amount) external onlyRebalancer {\\n        if (_fromToken == ETH) {\\n            // Only To WETH is allowed\\n            if (_toToken == WETH) {\\n                _wrap(_amount);\\n            } else if (_toToken == STETH) {\\n                _stakeETH(_amount);\\n            } else if (_toToken == RSETH) {\\n                _stakeRsETH(ETH, _amount);\\n            } else {\\n                revert Errors.UnsupportedToken();\\n            }\\n        } else if (_fromToken == WETH) {\\n            // Allow: to ETH, STETH, RSETH\\n            if (_toToken == ETH) {\\n                _unwrap(_amount);\\n            } else if (_toToken == STETH) {\\n                _unwrap(_amount);\\n                _stakeETH(_amount);\\n            } else if (_toToken == RSETH) {\\n                _stakeRsETH(WETH, _amount);\\n            } else {\\n                revert Errors.UnsupportedToken();\\n            }\\n        } else if (_fromToken == STETH) {\\n            if (_toToken == WSTETH) {\\n                _wrapStETH(_amount);\\n            } else if (_toToken == ETH) {\\n                _unstakeETH(_amount);\\n            } else if (_toToken == RSETH) {\\n                _stakeRsETH(STETH, _amount);\\n            } else {\\n                revert Errors.UnsupportedToken();\\n            }\\n        } else if (_fromToken == WSTETH) {\\n            // Only allow STETH\\n            if (_toToken == STETH) {\\n                _unwrapStETH(_amount);\\n            } else {\\n                revert Errors.UnsupportedToken();\\n            }\\n        } else if (_fromToken == RSETH) {\\n            // Allow: to STETH, ETH\\n            if (_toToken == STETH) {\\n                _unstakeRsETH(_amount, STETH);\\n            } else if (_toToken == ETH) {\\n                _unstakeRsETH(_amount, ETH);\\n            } else {\\n                revert Errors.UnsupportedToken();\\n            }\\n        } else {\\n            revert Errors.UnsupportedToken();\\n        }\\n    }\\n\\n    function confirmUnstakeETH() external onlyRebalancer {\\n        if (lidoUnstakeId == 0) revert Errors.IncorrectState();\\n        lidoQueue.claimWithdrawal(lidoUnstakeId);\\n        lidoUnstakeId = 0;\\n    }\\n\\n    function confirmUnstake() external onlyRebalancer {\\n        if (requestId == bytes32(0)) revert Errors.UnSupportedOperation();\\n        kelpWithdrawal.completeWithdrawal(STETH, \\\"\\\");\\n    }\\n\\n    function repay(address _token, uint256 _amount) external onlyRebalancer {\\n        executeRepay(_token, _amount);\\n\\n        emit Repay(_amount);\\n    }\\n\\n    function dummySwap(uint256 _amount, address _srcToken) internal returns (uint256) {\\n        uint256 rsETHAmountBefore_ = IERC20(RSETH).balanceOf(address(this));\\n        // If _srcToken is WETH\\n        if (_srcToken == WETH) {\\n            // Unwrap WETH to ETH\\n            IWETH(WETH).withdraw(_amount);\\n            kelpPool.depositETH{value: _amount}(0, \\\"\\\");\\n        } else if (_srcToken == STETH) {\\n            IERC20(STETH).safeIncreaseAllowance(address(kelpPool), _amount);\\n            kelpPool.depositAsset(STETH, _amount, 0, \\\"\\\");\\n        } else {\\n            revert Errors.UnSupportedOperation();\\n        }\\n        return IERC20(RSETH).balanceOf(address(this)) - rsETHAmountBefore_;\\n    }\\n\\n    /**\\n     * @dev Execute a leverage operation.\\n     * @param _deposit The amount to deposit.\\n     * @param _leverageAmount The amount to leverage.\\n     * @param _swapData The swap data.\\n     * @param _swapGetMin The minimum amount to get from the swap.\\n     * @param _flashloanSelector The flashloan selector.\\n     */\\n    function leverage(\\n        uint256 _deposit,\\n        address _borrowToken,\\n        uint256 _leverageAmount,\\n        bytes calldata _swapData,\\n        uint256 _swapGetMin,\\n        uint256 _flashloanSelector\\n    ) external onlyRebalancer tokenCheck(_borrowToken) {\\n        executeDeposit(SUPPLY_TOKEN, _deposit);\\n        checkProtocolRatio();\\n        if (_leverageAmount == 0) return;\\n        uint256 availableBorrowsAmount_ = getAvailableBorrowsAmount(_borrowToken);\\n        if (_leverageAmount < availableBorrowsAmount_) {\\n            leverageSelf(_borrowToken, _leverageAmount, _swapData, _swapGetMin);\\n        } else {\\n            executeFlashLoan(true, _borrowToken, _leverageAmount, _swapData, _swapGetMin, _flashloanSelector);\\n        }\\n        checkProtocolRatio();\\n\\n        emit Leverage(_deposit, _leverageAmount, _swapData, _flashloanSelector);\\n    }\\n\\n    /**\\n     * @dev Execute a deleverage operation.\\n     * @param _withdraw The amount to withdraw.\\n     * @param _deleverageAmount The amount to deleverage.\\n     * @param _swapData The swap data.\\n     * @param _swapGetMin The minimum amount to get from the swap.\\n     * @param _flashloanSelector The flashloan selector.\\n     */\\n    function deleverage(\\n        uint256 _withdraw,\\n        address _repayToken,\\n        uint256 _deleverageAmount,\\n        bytes calldata _swapData,\\n        uint256 _swapGetMin,\\n        uint256 _flashloanSelector\\n    ) external onlyRebalancer tokenCheck(_repayToken) {\\n        if (_deleverageAmount > 0) {\\n            uint256 availableWithdrawsAmount = getAvailableWithdrawsAmount();\\n            if (_deleverageAmount < availableWithdrawsAmount) {\\n                deleverageSelf(_repayToken, _deleverageAmount, _swapData, _swapGetMin);\\n            } else {\\n                executeFlashLoan(false, _repayToken, _deleverageAmount, _swapData, _swapGetMin, _flashloanSelector);\\n            }\\n        }\\n        executeWithdraw(SUPPLY_TOKEN, _withdraw);\\n        checkProtocolRatio();\\n        emit Deleverage(_deleverageAmount, _withdraw, _swapData, _flashloanSelector);\\n    }\\n\\n    /**\\n     * @dev Callback function for flashloan operations.\\n     * @param _initiator The address of the initiator.\\n     * @param _token The address of the token.\\n     * @param _amount The amount of tokens.\\n     * @param _fee The fee for the flashloan.\\n     * @param _params The parameters for the flashloan.\\n     * @return A bytes32 value indicating success.\\n     */\\n    function onFlashLoan(address _initiator, address _token, uint256 _amount, uint256 _fee, bytes calldata _params)\\n        external\\n        returns (bytes32)\\n    {\\n        if (msg.sender != flashloanHelper || executor == address(0) || _initiator != address(this)) {\\n            revert Errors.InvalidFlashloanCall();\\n        }\\n        (bool isLeverage_, bytes memory swapData_, uint256 swapGetMin_) = abi.decode(_params, (bool, bytes, uint256));\\n        isLeverage_\\n            ? leverageCallback(_token, _amount, _fee, swapData_, swapGetMin_)\\n            : deleverageCallback(_token, _amount, _fee, swapData_, swapGetMin_);\\n        IERC20(_token).safeIncreaseAllowance(msg.sender, _amount + _fee);\\n        return keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n    }\\n\\n    /**\\n     * @dev Get the available borrows in token.\\n     * @return availableBorrowsAmount_ The amount of available borrows in borrow token.\\n     */\\n    function getAvailableBorrowsAmount(address _token) public view returns (uint256 availableBorrowsAmount_) {\\n        (,, uint256 availableBorrowsInUsd_,,,) = POOL_AAVEV3.getUserAccountData(address(this));\\n        if (availableBorrowsInUsd_ > 0) {\\n            uint256 tokenPrice_ = ORACLE_AAVEV3.getAssetPrice(_token);\\n            availableBorrowsAmount_ = availableBorrowsInUsd_ * PRECISION / tokenPrice_;\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the available withdrawable amount in supply token.\\n     * @return maxWithdrawsAmount_ The maximum amount of supply token that can be withdrawn.\\n     */\\n    function getAvailableWithdrawsAmount() public view returns (uint256 maxWithdrawsAmount_) {\\n        (uint256 colInUsd_, uint256 debtInUsd_,,, uint256 ltv_,) = POOL_AAVEV3.getUserAccountData(address(this));\\n        if (colInUsd_ > 0) {\\n            uint256 colMin_ = debtInUsd_ * 1e4 / ltv_;\\n            uint256 maxWithdrawsInUsd_ = colInUsd_ > colMin_ ? colInUsd_ - colMin_ : 0;\\n            uint256 tokenPrice_ = ORACLE_AAVEV3.getAssetPrice(SUPPLY_TOKEN);\\n            maxWithdrawsAmount_ = maxWithdrawsInUsd_ * PRECISION / tokenPrice_;\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the collateral ratio and its status.\\n     * @return collateralRatio_ The collateral ratio.\\n     * @return isOK_ Boolean indicating whether the ratio is within safe limits.\\n     */\\n    function getCollateralRatio() public view returns (uint256 collateralRatio_, bool isOK_) {\\n        (uint256 totalCollateralBase_, uint256 totalDebtBase_,,,,) = POOL_AAVEV3.getUserAccountData(address(this));\\n        collateralRatio_ = totalCollateralBase_ == 0 ? 0 : totalDebtBase_ * PRECISION / totalCollateralBase_;\\n        isOK_ = safeProtocolRatio > collateralRatio_;\\n    }\\n\\n    /**\\n     * @dev Get the protocol account data.\\n     * @return stEthAmount_ The amount of supplied rsETH in stETH.\\n     * @return debtEthAmount_ The amount of debt in ETH.\\n     */\\n    function getProtocolAccountData() public view returns (uint256 stEthAmount_, uint256 debtEthAmount_) {\\n        uint256 rsEthAmount_ = IERC20(A_RSETH_AAVEV3).balanceOf(address(this));\\n        stEthAmount_ = getETHByRsETH(rsEthAmount_);\\n        uint256 debtWstEthAmount_ = IERC20(D_WSTETH_AAVEV3).balanceOf(address(this));\\n        debtEthAmount_ =\\n            IERC20(D_WETH_AAVEV3).balanceOf(address(this)) + IWstETH(WSTETH).getStETHByWstETH(debtWstEthAmount_);\\n    }\\n\\n    /**\\n     * @dev Get the amount of net assets in the protocol.\\n     * @return net_ The amount of net assets.\\n     */\\n    function getProtocolNetAssets() public view returns (uint256 net_) {\\n        (uint256 stEthAmount_, uint256 debtEthAmount_) = getProtocolAccountData();\\n        net_ = stEthAmount_ - debtEthAmount_;\\n    }\\n\\n    /**\\n     * @dev Get the amount of assets in all lending protocols involved in this contract for the strategy pool.\\n     * @return netAssets The total amount of net assets.\\n     */\\n    function getNetAssets() public view returns (uint256) {\\n        // if (block.timestamp - lastUpdateTime > maxPriceUpdatePeriod) {\\n        //     revert Errors.PriceNotUpdated();\\n        // }\\n        return netAssets;\\n    }\\n\\n    /**\\n     * @dev Execute a self-leverage operation.\\n     * @param _loanAmount The amount to loan.\\n     * @param _swapData The swap data.\\n     * @param _swapGetMin The minimum amount to get from the swap.\\n     */\\n    function leverageSelf(address _borrowToken, uint256 _loanAmount, bytes calldata _swapData, uint256 _swapGetMin)\\n        internal\\n    {\\n        executeBorrow(_borrowToken, _loanAmount);\\n        IERC20(_borrowToken).safeIncreaseAllowance(ONEINCH_ROUTER, _loanAmount);\\n        uint256 return_;\\n        if (_swapData.length == 0) {\\n            return_ = dummySwap(_loanAmount, _borrowToken);\\n        } else {\\n            (return_, ) = executeSwap(_loanAmount, _borrowToken, SUPPLY_TOKEN, _swapData, _swapGetMin);\\n        }\\n        executeDeposit(SUPPLY_TOKEN, return_);\\n    }\\n\\n    /**\\n     * @dev Execute a self-deleverage operation.\\n     * @param _deleverageAmount The amount to deleverage.\\n     * @param _swapData The swap data.\\n     * @param _swapGetMin The minimum amount to get from the swap.\\n     */\\n    function deleverageSelf(\\n        address _repayToken,\\n        uint256 _deleverageAmount,\\n        bytes calldata _swapData,\\n        uint256 _swapGetMin\\n    ) internal {\\n        executeWithdraw(SUPPLY_TOKEN, _deleverageAmount);\\n        IERC20(SUPPLY_TOKEN).safeIncreaseAllowance(ONEINCH_ROUTER, _deleverageAmount);\\n        (uint256 return_,) = executeSwap(_deleverageAmount, SUPPLY_TOKEN, _repayToken, _swapData, _swapGetMin);\\n        executeRepay(_repayToken, return_);\\n    }\\n\\n    /**\\n     * @dev Execute a flashloan operation.\\n     * @param _isLeverage Boolean indicating whether the operation is leverage.\\n     * @param _loanAmount The amount to loan.\\n     * @param _swapData The swap data.\\n     * @param _swapGetMin The minimum amount to get from the swap.\\n     * @param _flashloanSelector The flashloan selector.\\n     */\\n    function executeFlashLoan(\\n        bool _isLeverage,\\n        address _loanToken,\\n        uint256 _loanAmount,\\n        bytes calldata _swapData,\\n        uint256 _swapGetMin,\\n        uint256 _flashloanSelector\\n    ) internal {\\n        bytes memory params_ = abi.encode(_isLeverage, _swapData, _swapGetMin);\\n        bytes memory dataBytes_ = abi.encode(_flashloanSelector, this.onFlashLoan.selector, params_);\\n\\n        if (executor != address(0)) revert Errors.FlashloanInProgress();\\n        executor = msg.sender;\\n        IFlashloanHelper(flashloanHelper).flashLoan(\\n            IERC3156FlashBorrower(address(this)), _loanToken, _loanAmount, dataBytes_\\n        );\\n        executor = address(0);\\n    }\\n\\n    /**\\n     * @dev Execute a deposit operation in the AAVE protocol.\\n     * @param _asset The address of the asset to deposit.\\n     * @param _amount The amount of the asset to deposit.\\n     */\\n    function executeDeposit(address _asset, uint256 _amount) internal {\\n        if (_asset != SUPPLY_TOKEN) revert Errors.InvalidAsset();\\n        if (_amount == 0) return;\\n        POOL_AAVEV3.supply(SUPPLY_TOKEN, _amount, address(this), 0);\\n    }\\n\\n    /**\\n     * @dev Execute a withdrawal operation in the AAVE protocol.\\n     * @param _asset The address of the asset to withdraw.\\n     * @param _amount The amount of the asset to withdraw.\\n     */\\n    function executeWithdraw(address _asset, uint256 _amount) internal {\\n        if (_asset != SUPPLY_TOKEN) revert Errors.InvalidAsset();\\n        if (_amount == 0) return;\\n        POOL_AAVEV3.withdraw(SUPPLY_TOKEN, _amount, address(this));\\n    }\\n\\n    /**\\n     * @dev Execute a borrow operation in the AAVE protocol.\\n     * @param _asset The address of the asset to borrow.\\n     * @param _amount The amount of the asset to borrow.\\n     */\\n    function executeBorrow(address _asset, uint256 _amount) internal {\\n        if (_asset != WETH && _asset != WSTETH) revert Errors.InvalidAsset();\\n        if (_amount == 0) return;\\n        POOL_AAVEV3.borrow(_asset, _amount, 2, 0, address(this));\\n    }\\n\\n    /**\\n     * @dev Execute a repay operation in the AAVE protocol.\\n     * @param _asset The address of the asset to repay.\\n     * @param _amount The amount of the asset to repay.\\n     */\\n    function executeRepay(address _asset, uint256 _amount) internal {\\n        if (_asset != WETH && _asset != WSTETH) revert Errors.InvalidAsset();\\n        if (_amount == 0) return;\\n        POOL_AAVEV3.repay(_asset, _amount, 2, address(this));\\n    }\\n\\n    /**\\n     * @dev Enter the AAVE protocol by approving tokens.\\n     */\\n    function enterProtocol() internal {\\n        IERC20(STETH).safeIncreaseAllowance(RSETH, type(uint256).max);\\n        IERC20(WETH).safeIncreaseAllowance(address(POOL_AAVEV3), type(uint256).max);\\n        IERC20(RSETH).safeIncreaseAllowance(address(POOL_AAVEV3), type(uint256).max);\\n        IERC20(WSTETH).safeIncreaseAllowance(address(POOL_AAVEV3), type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Check the health status of a specific protocol after an operation\\n     * to prevent the strategy pool from being in a risky position.\\n     */\\n    function checkProtocolRatio() internal view {\\n        (, bool isOK_) = getCollateralRatio();\\n        if (!isOK_) revert Errors.RatioOutOfRange();\\n    }\\n\\n    function getETHByRsETH(uint256 _rsethAmount) public view returns (uint256) {\\n        uint256 rate_ = kelpOracle.rsETHPrice();\\n        return _rsethAmount * rate_ / PRECISION;\\n    }\\n\\n    function getRsETHByETH(uint256 _ethAmount) public view returns (uint256) {\\n        return kelpPool.getRsETHAmountToMint(ETH, _ethAmount);\\n    }\\n\\n    /**\\n     * @dev Callback function for leverage flashloan.\\n     * @param _loanAmount The loan amount.\\n     * @param _fee The fee for the flashloan.\\n     * @param _swapData The swap data.\\n     * @param _swapGetMin The minimum amount to get from the swap.\\n     */\\n    function leverageCallback(\\n        address _loanToken,\\n        uint256 _loanAmount,\\n        uint256 _fee,\\n        bytes memory _swapData,\\n        uint256 _swapGetMin\\n    ) internal {\\n        IERC20(_loanToken).safeIncreaseAllowance(ONEINCH_ROUTER, _loanAmount);\\n        uint256 return_;\\n        if (_swapData.length == 0) {\\n            return_ = dummySwap(_loanAmount, _loanToken);\\n        } else {\\n            (return_, ) = executeSwap(_loanAmount, _loanToken, SUPPLY_TOKEN, _swapData, _swapGetMin);\\n        }\\n        executeDeposit(SUPPLY_TOKEN, return_);\\n        executeBorrow(_loanToken, _loanAmount + _fee);\\n    }\\n\\n    /**\\n     * @dev Callback function for deleverage flashloan.\\n     * @param _loanAmount The loan amount.\\n     * @param _fee The fee for the flashloan.\\n     * @param _swapData The swap data.\\n     * @param _swapGetMin The minimum amount to get from the swap.\\n     */\\n    function deleverageCallback(\\n        address _loanToken,\\n        uint256 _loanAmount,\\n        uint256 _fee,\\n        bytes memory _swapData,\\n        uint256 _swapGetMin\\n    ) internal {\\n        executeRepay(_loanToken, _loanAmount);\\n        executeWithdraw(SUPPLY_TOKEN, _loanAmount);\\n        IERC20(SUPPLY_TOKEN).safeIncreaseAllowance(ONEINCH_ROUTER, _loanAmount);\\n        (uint256 return_,) = executeSwap(_loanAmount, SUPPLY_TOKEN, _loanToken, _swapData, _swapGetMin);\\n        uint256 repayFlashloan_ = _loanAmount + _fee;\\n        if (repayFlashloan_ > return_) {\\n            uint256 borrowAgain_ = repayFlashloan_ - return_;\\n            executeBorrow(_loanToken, borrowAgain_);\\n        } else if (repayFlashloan_ < return_) {\\n            uint256 rapayAgain_ = return_ - repayFlashloan_;\\n            executeRepay(_loanToken, rapayAgain_);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/main/swap/OneInchCallerV6.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.25;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../../interfaces/1inch/AddressLib.sol\\\";\\nimport \\\"../../interfaces/1inch/IAggregationRouterV6.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\nimport \\\"../common/Constants.sol\\\";\\n\\n/**\\n * @title OneInchCallerV6 contract\\n * @author Naturelab\\n * @notice The focal point of interacting with the 1inch protocol.\\n * @dev This contract will be inherited by the strategy contract and the wrapper contract,\\n * used for the necessary exchange between different tokens when necessary.\\n * @dev When using this contract, it is necessary to first obtain the calldata through 1inch API.\\n * The contract will then extract and verify the calldata before proceeding with the exchange.\\n */\\ncontract OneInchCallerV6 is Constants {\\n    // 1inch v6 protocol is currently in use.\\n    address public constant ONEINCH_ROUTER = 0x111111125421cA6dc452d289314280a0f8842A65;\\n\\n    using AddressLib for UAddress;\\n\\n    /**\\n     * @dev Separate the function signature and detailed parameters in the calldata.\\n     * This approach is used because memory variables in Solidity do not support slicing\\n     * operations directly. By using inline assembly, we can manually handle memory operations\\n     * to extract and copy the necessary parts of the data efficiently.\\n     * @param _swapData Calldata of 1inch.\\n     * @return functionSignature_ Function signature of the swap method.\\n     * @return remainingBytes_ The remaining bytes after the function signature.\\n     */\\n    function parseSwapCalldata(bytes memory _swapData)\\n        internal\\n        pure\\n        returns (bytes4 functionSignature_, bytes memory remainingBytes_)\\n    {\\n        assembly {\\n            // Extract function signature (first 4 bytes)\\n            functionSignature_ := mload(add(_swapData, 32))\\n\\n            // Calculate remaining data length\\n            let remainingLength := sub(mload(_swapData), 4)\\n\\n            // Allocate memory and copy remaining data\\n            remainingBytes_ := mload(0x40)\\n            mstore(remainingBytes_, remainingLength)\\n            let dst := add(remainingBytes_, 32)\\n            let src := add(_swapData, 36)\\n\\n            for { let end := add(dst, remainingLength) } lt(dst, end) {\\n                dst := add(dst, 32)\\n                src := add(src, 32)\\n            } { mstore(dst, mload(src)) }\\n\\n            // Update free memory pointer\\n            mstore(0x40, add(remainingBytes_, add(remainingLength, 32)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Executes the swap operation and verify the validity of the parameters and results.\\n     * @param _amount The maximum amount of currency spent.\\n     * @param _srcToken The token to be spent.\\n     * @param _dstToken The token to be received.\\n     * @param _swapData Calldata of 1inch.\\n     * @param _swapGetMin Minimum amount of the token to be received.\\n     * @return returnAmount_ Actual amount of the token spent.\\n     * @return spentAmount_ Actual amount of the token received.\\n     */\\n    function executeSwap(\\n        uint256 _amount,\\n        address _srcToken,\\n        address _dstToken,\\n        bytes memory _swapData,\\n        uint256 _swapGetMin\\n    ) internal returns (uint256 returnAmount_, uint256 spentAmount_) {\\n        (bytes4 functionSignature_, bytes memory remainingBytes_) = parseSwapCalldata(_swapData);\\n        bytes memory returnData_;\\n        if (functionSignature_ == IAggregationRouterV6.swap.selector) {\\n            (, IAggregationRouterV6.SwapDescription memory desc_,) =\\n                abi.decode(remainingBytes_, (IAggregationExecutor, IAggregationRouterV6.SwapDescription, bytes));\\n            if (address(this) != desc_.dstReceiver) revert Errors.OneInchInvalidReceiver();\\n            if (IERC20(_srcToken) != desc_.srcToken || IERC20(_dstToken) != desc_.dstToken) {\\n                revert Errors.OneInchInvalidToken();\\n            }\\n            if (_amount < desc_.amount) revert Errors.OneInchInvalidInputAmount();\\n\\n            if (_srcToken == ETH) {\\n                returnData_ = Address.functionCallWithValue(ONEINCH_ROUTER, _swapData, _amount);\\n            } else {\\n                returnData_ = Address.functionCall(ONEINCH_ROUTER, _swapData);\\n            }\\n            (returnAmount_, spentAmount_) = abi.decode(returnData_, (uint256, uint256));\\n            if (spentAmount_ > desc_.amount) revert Errors.OneInchUnexpectedSpentAmount();\\n            if (returnAmount_ < _swapGetMin) revert Errors.OneInchUnexpectedReturnAmount();\\n            return (returnAmount_, spentAmount_);\\n        }\\n\\n        if (\\n            functionSignature_ == IAggregationRouterV6.ethUnoswap.selector\\n                || functionSignature_ == IAggregationRouterV6.ethUnoswap2.selector\\n                || functionSignature_ == IAggregationRouterV6.ethUnoswap3.selector\\n        ) {\\n            if (_srcToken != ETH || _dstToken == ETH) revert Errors.OneInchNotSupported();\\n            uint256 tokenBefore_ = IERC20(_dstToken).balanceOf(address(this));\\n            uint256 ethBal_ = address(this).balance;\\n            returnData_ = Address.functionCallWithValue(ONEINCH_ROUTER, _swapData, _amount);\\n            spentAmount_ = ethBal_ - address(this).balance;\\n            returnAmount_ = IERC20(_dstToken).balanceOf(address(this)) - tokenBefore_;\\n            if (spentAmount_ != _amount) revert Errors.OneInchUnexpectedSpentAmount();\\n            if (returnAmount_ < _swapGetMin) revert Errors.OneInchUnexpectedReturnAmount();\\n            return (returnAmount_, spentAmount_);\\n        }\\n\\n        UAddress srcTokenFromCalldata_;\\n        if (\\n            functionSignature_ == IAggregationRouterV6.unoswap.selector\\n                || functionSignature_ == IAggregationRouterV6.unoswap2.selector\\n                || functionSignature_ == IAggregationRouterV6.unoswap3.selector\\n        ) {\\n            (srcTokenFromCalldata_, spentAmount_) = abi.decode(remainingBytes_, (UAddress, uint256));\\n        } else {\\n            revert Errors.OneInchInvalidFunctionSignature();\\n        }\\n        if (srcTokenFromCalldata_.get() != _srcToken || _srcToken == ETH) revert Errors.OneInchNotSupported();\\n        if (_amount < spentAmount_) revert Errors.OneInchInvalidInputAmount();\\n        uint256 unoswapTokenBefore_ = IERC20(_dstToken).balanceOf(address(this));\\n        returnData_ = Address.functionCall(ONEINCH_ROUTER, _swapData);\\n        returnAmount_ = IERC20(_dstToken).balanceOf(address(this)) - unoswapTokenBefore_;\\n        if (returnAmount_ < _swapGetMin) revert Errors.OneInchUnexpectedReturnAmount();\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotRebalancer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FlashloanInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectState\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAsset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFlashloanCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFlashloanHelper\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRebalancer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSafeProtocolRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUnderlyingToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWithdrawalUser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MathOverflowedMulDiv\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OneInchInvalidFunctionSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OneInchInvalidInputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OneInchInvalidReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OneInchInvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OneInchNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OneInchUnexpectedReturnAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OneInchUnexpectedSpentAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceUpdatePeriodTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RatioOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnSupportedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deleverageAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flashloanSelector\",\"type\":\"uint256\"}],\"name\":\"Deleverage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flashloanSelector\",\"type\":\"uint256\"}],\"name\":\"Leverage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OnTransferIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeRsETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapGet\",\"type\":\"uint256\"}],\"name\":\"SwapToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferToVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeRsETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldCeffu\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCeffu\",\"type\":\"address\"}],\"name\":\"UpdateCeffu\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFlashloanHelper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFlashloanHelper\",\"type\":\"address\"}],\"name\":\"UpdateFlashloanHelper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"netAssets\",\"type\":\"uint256\"}],\"name\":\"UpdateNetAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRebalancer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRebalancer\",\"type\":\"address\"}],\"name\":\"UpdateRebalancer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSafeProtocolRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSafeProtocolRatio\",\"type\":\"uint256\"}],\"name\":\"UpdateSafeProtocolRatio\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE_UPDATED_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PROTOCOL_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONEINCH_ROUTER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RSETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WSTETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ceffu\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmUnstakeETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"convertToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdraw\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_repayToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deleverageAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_swapData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_swapGetMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_flashloanSelector\",\"type\":\"uint256\"}],\"name\":\"deleverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashloanHelper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getAvailableBorrowsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"availableBorrowsAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableWithdrawsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWithdrawsAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralRatio_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOK_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rsethAmount\",\"type\":\"uint256\"}],\"name\":\"getETHByRsETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNetAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolAccountData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtEthAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolNetAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"net_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"name\":\"getRsETHByETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_initBytes\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deposit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_leverageAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_swapData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_swapGetMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_flashloanSelector\",\"type\":\"uint256\"}],\"name\":\"leverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lidoUnstakeId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPriceUpdatePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"netAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onTransferIn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalancer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeProtocolRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swapData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_swapGetMin\",\"type\":\"uint256\"}],\"name\":\"swapToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferToCeffu\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferToVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCeffu\",\"type\":\"address\"}],\"name\":\"updateCeffu\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFlashloanHelper\",\"type\":\"address\"}],\"name\":\"updateFlashloanHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_netAssets\",\"type\":\"uint256\"}],\"name\":\"updateNetAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRebalancer\",\"type\":\"address\"}],\"name\":\"updateRebalancer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRatio\",\"type\":\"uint256\"}],\"name\":\"updateSafeProtocolRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "ContractName": "StrategyAAVEV3",
      "CompilerVersion": "v0.8.25+commit.b61c2a91",
      "CompilerType": "solc-j",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "cancun",
      "Library": "",
      "LicenseType": "",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "",
      "SimilarMatch": ""
    }
  ]
}